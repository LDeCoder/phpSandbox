/**

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.

?????????????????????????????????????????????????????
Test case	Explanation
l1=[0,1]l1=[0,1]
l2=[0,1,2]l2=[0,1,2]	When one list is longer than the other.

l1=[]l1=[]
l2=[0,1]l2=[0,1]	When one list is null, which means an empty list.

l1=[9,9]l1=[9,9]
l2=[1]l2=[1]	The sum could have an extra carry of one at the end, which is easy to forget.
??????????????????????????????????????????????????????

 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

solution without comments:
  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry = 0;
        while(p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            if(p != null) p = p.next;
            if(q != null) q = q.next;
        }
        if (carry > 0) {
            curr.next = new ListNode(carry);
        }
        return dummyHead.next;
    }



class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        
        // Initialize current node to dummy head of the returning list.
        ListNode dummyHead = new ListNode(0);
        
        // Initialize carry to 0.
        int carry = 0;
        
        // Initialize p and q to head of l1 and l2 respectively.
        while(p != null) || (q != null){
            
        // Loop through lists l1 and l2 until you reach both ends.
        // Set x to node p's value. If p has reached the end of l1, set to 0.
         int x = (p != null) ? p.val : 0;
        // Set y to node q's value. If q has reached the end of l2, set to 0.
         int y = (q != null) ? q.val : 0;
            
        // Set sum = x + y + carry
         int sum = carry + x + y;      
      
        // Update carry = sum / 10
        carry = sum/10;

        // Create a new node with the digit value of (sum % 10) and set it to                               current node's next, then advance current node to next.
        // Advance both p and q.
        if (p != mull) p = p.next;
        if (q != null) q = q.next;
            
        }
        // Check if carry = 1, if so append a new node with digit 11 to the returning list.
        if(carry > 0){
            curr.next = new ListNode(carry);
        }
        

//     Return dummy head's next node.
        return dummyHead.next;

        
    }





SUM OF TWO NUMBERS: Bitwise operation + loop / recursion:
JAVA:
class Solution {
    public int getSum(int a, int b) {
        /*
        Case 1:
        If all bits of a and b are different then a^b will give the sum.
        Here, we pass a^b as input a, which is the sum itself, to getSum. For b, we pass
        a&b. Since all bits are different, a&b will be 0 and a&b<<1 will also be 0.
        So the next recursive call will return the sum which is a^b itself.
        Case 2:
        Bits are different
        Lets say b is minimum of these a and b.
        We can represent a+b as b+b+(a-b). Here, b is partially common to b and a. Thus, we split a={a&b,|a-b|}. |a-b| is represented by a^b. So the remaining component is a&b. Since a+b=2(a&b)+|a-b|, we compute 2(a&b) as (a&b)<<1. We now pass these 2: a^b and a&b<<1 recursively to getSum.
        */
        return (a==0?b:(b==0?a:getSum(a^b,(a&b)<<1)));
    }
}


class Solution {
    public int getSum(int a, int b) {
        // If b or carry is 0, then return the number.
        if (b == 0) return a;
        
        // Else get sum of a xor b that gives a + b (without the carry)
        // And add carry to it, carry is just a AND b, left shifted by 1
        return getSum(a ^ b, (a & b) << 1);
    }
}

use increment and decrement operators:
class Solution {
    public int getSum(int a, int b) {
        if(b > 0)
        {
            while(b != 0)
            {
                a++;
                b--;
            }
        }
        else 
        {
            while(b != 0)
            {
                a--;
                b++;
            }
        }
        return a;
    }
}


I read a number of solutions posted in the forum and understand the use of AND and XOR bit operations.
 Howerver, I got confused with the code that variable 'b' was reused for different purpose.
  Therefore, as a novice of bitwise operations, I would like to share my java code that uses 
  separated sum/carry variables that can easily illustrate where AND and XOR operations were performed. 
  Hope this can help people understand.

class Solution {
    public int getSum(int a, int b) {
        if (a == 0){
            return b;
        }
        if (b == 0){
            return a;
        }
        int carry = (a & b) << 1;
        int sum  = a ^ b;
        while (carry != 0){
            int newSum = sum ^ carry;
            carry = (sum & carry) << 1;
            sum = newSum;
        }    
        return sum;        
    }
}


while (y != 0)  
    {  
        // carry now contains common set bits of x and y  
        int carry = x & y;  
  
        // Sum of bits of x and y where at least one of the bits is not set  
        x = x ^ y;  
  
        // Carry is shifted by one so that adding it to x gives the required sum  
        y = carry << 1;  
    }  
    return x;